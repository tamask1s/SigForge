GenerateModulatedECG(sim1, 240000, 1000,
{
    "heartbeat_frequency" : 1.2,
    "alteration_frequency_for_DC_component" : 0.01,
    "alteration_amplitude_for_DC_component" : 0.2,
    "alteration_phase_for_DC_component_in_radians": 0,
    "frequency_HF" : 0.2,
    "frequency_LF" : 0.01,
    "amplitude_modulation_depth_for_QRS_by_HF" : 0.2,
    "frequency_modulation_depth_HF" : 0.3,
    "frequency_modulation_depth_LF" : 0.3,
    "phase_HF_radians" : 0,
    "phase_LF_radians" : 0,
    "extrasys_frequency" : 0.023,
    "extrasys_shift_after_last_QRS" : 0.35,
    "QRS_interval_standard_deviation" : 0.0,
    "skip_one_QRS_at_every" : 37
},
{
    "amplitude_p" : 0.1,
    "amplitude_q" : -0.1,
    "amplitude_r" : 1.0,
    "amplitude_s" : -0.2,
    "amplitude_t" : 0.2,
    "len_p" : 0.08,
    "len_pq" : 0.08,
    "len_q" : 0.007,
    "len_r" : 0.1,
    "len_s" : 0.007,
    "len_st" : 0.1,
    "len_t" : 0.16
});

Copy(sim2, sim1);
CreateFilter(filter_lp, butterworth lp, 2 SAMPLING_RATE, 100);
CreateFilter(filter, butterworth bs, 1 SAMPLING_RATE, 49 52);
Filter(sim2, filter_lp);
Filter(sim2, filter);
DisplayData(sim2,,, C, 000);

AddNoise(sim1, 0.02, 50.0);
AddNoise(sim1, 0.12);
AddBandLimitedNoise(sim1, 0.95, 30, 70);
MeanSpectrum(sim1, ECG_spectrum, 235, 512);
DisplayData(sim1,,, C, 000);
DisplayData(ECG_spectrum);

// --------------------------------------------

#define SAMPLING_RATE 1000

DataIn(sim1, orig_sig_1, 1);
//DataDelete();

CreateFilter(bandpass_filter2, butterworth bp, 2 SAMPLING_RATE, 0.7 400);
Filter(orig_sig_1, bandpass_filter2);
FilterReverse(orig_sig_1, bandpass_filter2);

CreateFilter(bandstop_filter2, butterworth bs, 2 SAMPLING_RATE, 49.9 50.1);
Filter(orig_sig_1, bandstop_filter2);
FilterReverse(orig_sig_1, bandstop_filter2);

Copy(mother_sig1, orig_sig_1, 0);
Copy(mother_sig2, orig_sig_1, 0);

def SpikeDetector(ekgsignal, spikes, spike_radius, density_threshold, bo_low, bo_high, details)
{
    CreateFilter(bandpass_filter, butterworth bp, 2 SAMPLING_RATE, bo_low bo_high);
    CreateFilter(derivative_filter, butterworth hp, 2 SAMPLING_RATE, 10);
    CreateFilter(integrative_filter, butterworth lp, 2 SAMPLING_RATE, 8);
    CreateFilter(threshold_filter, butterworth lp, 2 SAMPLING_RATE, 1.5);
    Filter(ekgsignal, bandpass_filter);
    FilterReverse(ekgsignal, bandpass_filter);
    Filter(ekgsignal, derivative_filter);
    FilterReverse(ekgsignal, derivative_filter);
    SQR_Inplace(ekgsignal);
    Filter(ekgsignal, integrative_filter);
    FilterReverse(ekgsignal, integrative_filter);
    Copy(ekgsignal_threshold, ekgsignal);
    Filter(ekgsignal_threshold, threshold_filter);
    FilterReverse(ekgsignal_threshold, threshold_filter);
    DetectSpikes(spikes, ekgsignal, ekgsignal_threshold);
    CleanupSpikes(ekgsignal, spikes, spike_radius, density_threshold);
    if (details)
    {
        Cat(ekgsignal_threshold, ekgsignal);
        Cat(ekgsignal_threshold, spikes);
        DisplayData(ekgsignal_threshold, fit_width,, C, 001);
    };
};

SpikeDetector(mother_sig1, maternal_spikes, 0.3, 0.5, 8, 20, true);
RefineSpikes(mother_sig2, maternal_spikes, 0.3);

Cat(mother_sig2, maternal_spikes);

DisplayData(mother_sig2, fit_width,, C, 001);
//DisplayData(manage_windows, tile_vertically);

// ----------------------

DataIn(mother_sig2, spikes, 2);
RR_Distances(spikes, RRs, 0);
ARSpectrum(RRs, ar_spectrum, 16, 4, 256);
ResampleNNIntervals(RRs, RRsResampled, 10);
RemoveDCComponent(RRsResampled);
MeanSpectrum(RRsResampled, RR_spectrum, 35, 512);

Transpose(RRs_transposed, RRs);
WriteAscii(RRs_transposed, c:/tamas/RRs2.ascii);
DisplayData(RRs);
DisplayData(RRsResampled);
DisplayData(RR_spectrum);
DisplayData(ar_spectrum);

//--------------------

DataIn(RRs, pointcare, 1);
Copy(rrs2, pointcare);
PopFront(rrs2, 1);
PopBack(pointcare, 1);
Cat(pointcare, rrs2);
//Cat(pointcare, rrs2);
//Cat(pointcare, pointcare);
DisplayData(pointcare, fit_width, xy_plot);

//-----------------

DataIn(sim1, sim2, 1);
DataIn(sim1, sim3, 1);
Cat(sim2, sim2);
Cat(sim2, sim2);
Cat(sim2, sim2);
Cat(sim2, sim3);
Cat(sim2, sim3);
Cat(sim2, sim3);
Cat(sim2, sim3);
Cat(sim2, sim3);
Cat(sim2, sim3);
Cat(sim2, sim3);
Cat(sim2, spikes);
DisplayData(sim2);
SaveDataToFile(sim2, c:\Tamas\sim2.raw, 100, 10);
//---------------------
DataIn(DATASERIES7, datavartr, 1); 
FullSpectrum(datavartr, 
             spectrain2, 
             CopyForAllChannels(datavartr, 1), 
             2 250);
DisplayData(spectrain2,fit_width,2D_map);
//------------------

MVM ugyfélszolgálat
0630 474 9999

media_base.h is an implementation spec header, shouldnt be included anywhere else
media related things shouldnt be included in ipp
net related things shouldnt be included in media part


duplazodas
szures
104 vs 1040

unroll subnet.cpp for (int i = 0; i < IPV6_ADDR_LEN; ++i) 
is_ip_supported could return mask
we shouldnt crash in this case, pls use return value or catch: throw "get_ip_mask: Invalid IP version";
declare error_msg as string reference
in ipc_msg_q: HTTP_client_json http_client{ "localhost", 8081 }; - 8081 should come from param



 - maybe we could have perf test to compare multiple mgen performance with and without using ipp.

 - also we could have a test to measure maximum throughput somehow with a given setup